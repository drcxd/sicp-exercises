#+title: Exercise 5.38

* How to deal with arbitrary number of arguments?

We have to compile expressions such as ~(* 1 2 3 4)~ or ~(* a b c d)~. We have only two argument registers, so we must accumulate the results so far in one register, put the next argument in another register, and perform the operation.

Racket's evaluates ~(*)~ to ~1~ and ~(+)~ to ~0~ by default. Thus, my algorithm is:

To apply ~+~ on any number of arguments:

1. Put ~0~ in to register ~arg1~
2. If there are no more arguments, assign the value in ~arg1~ to ~val~.
3. Otherwise, generate code to evaluate the next argument, and move the result to ~arg2~.
4. Generate code to apply the operation upon ~arg1~ and ~arg2~, and move the result to ~arg1~. Go back to 2.

* Optimizations

The algorithm described above works, but we can further optimize it.

In fact, the code that initializes ~arg1~ to operation identity is only required when there is no operands. When there is only one operand, we can simply evaluate the operand and assign it to the target. When there are multiple operands, we use the following algorithms:

1. Evaluate the first operand to ~arg1~.
2. For the rest operands, if there is only one argument left, evaluate to ~arg2~, apply the operation on ~arg1~ and ~arg2~ to target.
3. Otherwise, evaluate the next argument to ~arg2~.
4. Apply the operation upon ~arg1~ and ~arg2~ to ~arg1~. Go back to 2.


Another optimization we can do is to remove the evaluation for self-evaluating operands. For example, currently the compiler generates the following code:

#+begin_src scheme
   (assign arg1 (const 2))
   (assign arg2 (const 3))
   (assign arg1 (op *) (reg arg1) (reg arg2))
   (assign arg2 (const 4))
   (assign arg1 (op *) (reg arg1) (reg arg2))
   (assign arg2 (const 5))
   (assign val (op *) (reg arg1) (reg arg2)))
#+end_src

The assignment to ~arg1~ and ~arg2~ are redundant in this case. The optimal code would be:

#+begin_src scheme
  (assign arg1 (op *) (const 2) (const 3))
  (assign arg1 (op *) (reg arg1) (const 4))
  (assign arg1 (op *) (reg arg1) (const 4))
  (assign val (op *) (reg arg1) (const 5))
#+end_src

How to do this? We have to modify the algorithm for multiple operands above.

For the first two operands:

1. If both are self evaluated, then we directly perform the requested operation upon them.
2. If the first is self evaluated, but the second is not, then we evaluate the second operand to ~arg1~, and then perform the operation upon them.
3. If the first is not self evaluated, but the second is, then we evaluate the first operand to ~arg1~, and then perform the operation upon them.
4. If the both are not self evaluated, then we evaluate the first operand to ~arg1~, and the second operand to ~arg2~, then perform the operation upon them.


If there are no other operands, then the target of the operation above is the input target. Otherwise, the target is ~arg1~. And the program transfer into a loop.

In the loop:

1. If there is only one operand left:
   1. If it is self evaluated, then perform the operation upon ~arg1~ and the expression to the target
   2. Otherwise, evaluate the operand to ~arg2~ and perform the operation upon ~arg1~ and ~arg2~ to the target.
2. Otherwise,
   1. If the next operand is self evaluated, we perform the operation upon ~arg1~ and it to ~arg1~.
   2. Otherwise, we evaluate the next operand to ~arg2~ and perform the operation upon 
