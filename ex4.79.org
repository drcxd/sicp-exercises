#+title: Exercise 4.79

The difference between rule application and procedure application:

The purpose of rule application is to figure out the value of some
arguments, the value of the arguments are not known before the rule is
applied, and may be known after the application.

The purpose of procedure application is to compute a return value,
while all the value of its input arguments are known.

In procedure application, if an inner environment defines a variable
that has the same name as a variable in its outer environment, then
the inner variable hides the outer variable. It is impossible to
access that outer variable in this inner environment.

In rule application, things are different. An inner variable may bind
to an outer variable, which may share the same name with one of the
inner variables.

* A Possible Solution

** Environment Structure

Every evaluation works in an environment. An environment is a list of
frames. Each frames contains two regions: Region I and Region
II. Region I is a list of bindings for the variables in the query,
while Region II is a list of bindings for the variables in the rule.

Variables in Region I can be bound to variables in Region II, while
variables in Region II can only be bound to values.

An environment starts with an empty frame, i.e., both regions of it
contains no bindings.

** Workflow

Matching assertions would only use Region II of the initial frame.

When the unifying of a rule application finishes, a frame is generated
and inserted to the front of the environment.

Before applying the rule body, the variables used in the rule
conclusion is replaced by their values, if they are bound in the
Region II of the frame.

When a rule application finishes, the program first tries to resolve
the bindings in Region I of its frame. Then the program moves the
binding in the Region I of its frame to the Region II of the frame
behind it in the list.

Instantiating basically works as before, but it only works on the
Region II of frames.

** Example

#+begin_src scheme
  ;; Rule definition
  (rule (last-pair (?x . ()) (?x)))
  (rule (last-pair (?x . ?y) ?z)
        (last-pair ?y ?z))
  ;; Query
  (last-pair (1 2 3) ?x)
#+end_src

The following graph illustrates the first half process of applying a
rule. The process starts with processing the query ~(last-pair (1 2 3)
?x)~. The =Environment= part shows its frame after unifying the rule with
the query. The query ~(last-pair (2 3) ?z)~ right to the first query is
the body of the first query, instantiated using the data in its
frame. ~?y~ is instantiated as ~(2 3)~, while ~?z~ is not instantiated since
it is not bound yet. The same process keeps until the last query
~(last-pair (3) ?z)~ which is unified with the rule ~(last-pair (?x . ())
(?x))~ that is always true.

#+begin_example
  Query: (last-pair (1 2 3) ?x)  -> Query: (last-pair (2 3) ?z) -> Query: (last-pair (3) ?z)

  Environment:

  ?x -> ?z | ?x -> 1                ?z -> ?z | ?x -> 2             ?z -> (?x) | ?x -> 3
           | ?y -> (2 3)                     | ?y -> (3)
#+end_example

The following graph illustrates the last half process of applying a
rule. When a rule application finishes, the program tries to use the
bindings in Region II of its frame to resolve bindings in Region I of
the frame. Then, the program transfers the bindings in Region I of the
frame to the Region II of the frame behind the current one. The
process repeats until all rule application finishes, and the binding
for ~?x -> (3)~ is moved to the Region II of the initial empty frame.

#+begin_example
  Query: (last-pair (1 2 3) ?x)  <- Query: (last-pair (2 3) ?z) <- Query: (last-pair (3) ?z)

  Environment:

  ?x -> ?z | ?x -> 1                ?z -> ?z | ?x -> 2             ?z -> (?x) | ?x -> 3
  ?x -> (3)| ?y -> (2 3)            ?z -> (3)| ?y -> (3)           ?z -> (3)
           | ?z -> (3)                       | ?z -> (3)
#+end_example

Another example is illustrated as follows:

#+begin_src scheme
  (rule (append-to-form () ?y ?y))
  (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                    (append-to-form ?v ?y ?z))
#+end_src

#+begin_example
  Query: (append-to-form (1 2) (3) ?x) -> (append-to-form (2) (3) ?z)  -> (append-to-form () (3) ?z)

  Environment:

  ?x -> (?u . ?z) | ?u -> 1               ?z -> (?u . ?z) | ?u -> 2       ?z -> ?y | ?y -> (3)
                  | ?v -> (2)                             | ?v -> ()
                  | ?y -> (3)                             | ?y -> (3)
#+end_example

#+begin_example
  Query: (append-to-form (1 2) (3) ?x) <- (append-to-form (2) (3) ?z)  <- (append-to-form () (3) ?z)

  Environment:

  ?x -> (?u . ?z) | ?u -> 1               ?z -> (?u . ?z) | ?u -> 2       ?z -> ?y | ?y -> (3)
  ?x -> (1 2 3)   | ?v -> (2)             ?z -> (2 3)     | ?v -> ()      ?z -> (3)|
                  | ?y -> (3)                             | ?y -> (3)
                  | ?z -> (2 3)                           | ?z -> (3)
#+end_example

** Problem of the Solution

This solution has the problem that it can not solve a rule application
if one of the variables in the initial query have no direct matching
variable in the rule conclusion.

For example, the rule application ~(last-pair (1 ?x) (2))~ can be solved
in the original query system and ~?x~ is resolved to be ~(2)~. In the
current solution, ~(?x)~ matches ~?y~ in the rule conclusion. I have no
idea how to express ~?x~ in such a situation.

I think the nature of the problem is that the current solution is
similar to how procedures are applied in a Scheme evaluation. There is
an assumption that every argument can be evaluated and only the return
value should be computed. However, in the query system, this no longer
holds true.

*** A Workaround

If the region I in a frame generated by unifying does contain any
unresolved bindings, such a frame should be discarded. That is, it
will not be inserted to the front of the environment. This is natural
since it will not provide further information to the frame behind it
if it had been inserted to the front of the environment.

Then, when instantiating the rule body, we only instantiate any
variable to its immediate value. That is, if a variable =u= is bound to
another variable =v=, we instantiate =u= use =v= rather than the value of =v=.

This is based on the following assertion (which may not be true):

If a region II variable is bound to another variable, then that
variable is not a region II variable, but may share the same name with
a region II variable.

I name such an instantiating as a shallow instantiating.

After a shallow instantiating, a query that has the problem mentioned
in this section should be transformed into a query that no longer has
such problem.

*** Result

Fortunately, such a workaround works for rules ~last-pair~ and
~append-to-form~ as mentioned above.

Test code for the system:

#+begin_src scheme
  (add-multiple-assert '((rule (last-pair (?x .()) (?x)))
                         (rule (last-pair (?x . ?y) ?z)
                               (last-pair ?y ?z))
                         (rule (append-to-form () ?y ?y))
                         (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                               (append-to-form ?v ?y ?z))
                         (salary John 1000)
                         (salary Mary 500)
                         (address Mary China)))
#+end_src

** Future Work

Detection for circular dependencies and loops.
