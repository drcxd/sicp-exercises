#+title: Exercise 4.79

The difference between rule application and procedure application:

The purpose of rule application is to figure out the value of some
arguments, the value of the arguments are not known before the rule is
applied, and may be known after the application.

The purpose of procedure application is to compute a return value,
while all the value of its input arguments are known. Thus, in
procedure application, duplicated variable names from outer
environments are always eliminated since they have become

In procedure application, if an inner environment defines a variable
that has the same name as a variable in its outer environment, then
the inner variable hides the outer variable. It is impossible to
access that outer variable in this inner environment.

In rule application, things are different. An inner variable may bind
to an outer variable, which may share the same name with one of the
inner variables.

* A Possible Solution

** Environment Structure

Every evaluation works in an environment. An environment is a list of
frames. Each frames contains two regions: Region I and Region
II. Region I is a list of bindings for the variables in the query,
while Region II is a list of bindings for the variables in the rule.

Variables in Region I can be bound to variables in Region II, while
variables in Region II can only be bound to values.

An environment starts with an empty frame, i.e., both regions of it
contains no bindings.

** Workflow

Matching assertions would only use Region I of the initial frame.

When the unifying of a rule application finishes, a frame is generated
and inserted to the front of the environment.

Before applying the rule body, the variables used in the rule
conclusion is replaced by their values, if they are bound in the
Region II of the frame.

When a rule application finishes, the program first tries to resolve
the bindings in Region I of its frame. Then the program moves the
binding in the Region I of its frame to the Region II of the frame
behind it in the list.

Instantiating basically works as before, but it only works on the
Region II of frames.

** Example

#+begin_src scheme
  ;; Rule definition
  (rule (last-pair (?x . ()) (?x)))
  (rule (last-pair (?x . ?y) ?z)
        (last-pair ?y ?z))
  ;; Query
  (last-pair (1 2 3) ?x)
#+end_src

The following graph illustrates the first half process of applying a
rule. The process starts with processing the query ~(last-pair (1 2 3)
?x)~. The =Environment= part shows its frame after unifying the rule with
the query. The query ~(last-pair (2 3) ?z)~ right to the first query is
the body of the first query, instantiated using the data in its
frame. ~?y~ is instantiated as ~(2 3)~, while ~?z~ is not instantiated since
it is not bound yet. The same process keeps until the last query
~(last-pair (3) ?z)~ which is unified with the rule ~(last-pair (?x . ())
(?x))~ that is always true.

#+begin_example
  Query: (last-pair (1 2 3) ?x)  -> Query: (last-pair (2 3) ?z) -> Query: (last-pair (3) ?z)

  Environment:

  ?x -> ?z | ?x -> 1                ?z -> ?z | ?x -> 2             ?z -> (?x) | ?x -> 3
           | ?y -> (2 3)                     | ?y -> (3)
#+end_example

The following graph illustrates the last half process of applying a
rule. When a rule application finishes, the program tries to use the
bindings in Region II of its frame to resolve bindings in Region I of
the frame. Then, the program transfers the bindings in Region I of the
frame to the Region II of the frame behind the current one. The
process repeats until all rule application finishes, and the binding
for ~?x -> (3)~ is moved to the Region II of the initial empty frame.

#+begin_example
  Query: (last-pair (1 2 3) ?x)  <- Query: (last-pair (2 3) ?z) <- Query: (last-pair (3) ?z)

  Environment:

  ?x -> ?z | ?x -> 1                ?z -> ?z | ?x -> 2             ?z -> (?x) | ?x -> 3
  ?x -> (3)| ?y -> (2 3)            ?z -> (3)| ?y -> (3)           ?z -> (3)
           | ?z -> (3)                       | ?z -> (3)
#+end_example

Another example is illustrated as follows:

#+begin_src scheme
  (rule (append-to-form () ?y ?y))
  (rule (append-to-form (?u . ?v) ?y (?u . ?z))
                    (append-to-form ?v ?y ?z))
#+end_src

#+begin_example
  Query: (append-to-form (1 2) (3) ?x) -> (append-to-form (2) (3) ?z)  -> (append-to-form () (3) ?z)

  Environment:

  ?x -> (?u . ?z) | ?u -> 1               ?z -> (?u . ?z) | ?u -> 2       ?z -> ?y | ?y -> (3)
                  | ?v -> (2)                             | ?v -> ()
                  | ?y -> (3)                             | ?y -> (3)
#+end_example

#+begin_example
  Query: (append-to-form (1 2) (3) ?x) <- (append-to-form (2) (3) ?z)  <- (append-to-form () (3) ?z)

  Environment:

  ?x -> (?u . ?z) | ?u -> 1               ?z -> (?u . ?z) | ?u -> 2       ?z -> ?y | ?y -> (3)
  ?x -> (1 2 3)   | ?v -> (2)             ?z -> (2 3)     | ?v -> ()      ?z -> (3)|
                  | ?y -> (3)                             | ?y -> (3)
                  | ?z -> (2 3)                           | ?z -> (3)
#+end_example
