#+title: Exercise 5.37

We simply remove the ~if~ expression in ~preserving~ and unconditionally preservers the requested registers. The code produced by the compiler after modification:

#+begin_src scheme
  ((continue env)
   (val)
   ((save continue)
    (save env)
    (save continue)
    (assign val (op make-compiled-procedure) (label entry1) (reg env))
    (restore continue)
    (goto (label after-lambda2))
    entry1
    (assign env (op compiled-procedure-env) (reg proc))
    (assign env (op extend-environment) (const (n)) (reg argl) (reg env))
    (save continue)
    (save env)
    (save continue)
    (save env)
    (save continue)
    (assign val (op make-compiled-procedure) (label entry3) (reg env))
    (restore continue)
    (goto (label after-lambda4))
    entry3
    (assign env (op compiled-procedure-env) (reg proc))
    (assign
     env
     (op extend-environment)
     (const (product counter))
     (reg argl)
     (reg env))
    (save continue)
    (save env)
    (save continue)
    (save env)
    (save continue)
    (assign proc (op lookup-variable-value) (const >) (reg env))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save proc)
    (save env)
    (save continue)
    (assign val (op lookup-variable-value) (const n) (reg env))
    (restore continue)
    (assign argl (op list) (reg val))
    (restore env)
    (save argl)
    (save continue)
    (assign val (op lookup-variable-value) (const counter) (reg env))
    (restore continue)
    (restore argl)
    (assign argl (op cons) (reg val) (reg argl))
    (restore proc)
    (restore continue)
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-branch8))
    compiled-branch9
    (assign continue (label after-call10))
    (assign val (op compiled-procedure-entry) (reg proc))
    (goto (reg val))
    primitive-branch8
    (save continue)
    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    (restore continue)
    after-call10
    (restore env)
    (restore continue)
    (test (op false?) (reg val))
    (branch (label false-branch6))
    true-branch5
    (save continue)
    (assign val (op lookup-variable-value) (const product) (reg env))
    (restore continue)
    (goto (reg continue))
    false-branch6
    (save continue)
    (save env)
    (save continue)
    (assign proc (op lookup-variable-value) (const iter) (reg env))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save proc)
    (save env)
    (save continue)
    (save env)
    (save continue)
    (assign proc (op lookup-variable-value) (const +) (reg env))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save proc)
    (save env)
    (save continue)
    (assign val (const 1))
    (restore continue)
    (assign argl (op list) (reg val))
    (restore env)
    (save argl)
    (save continue)
    (assign val (op lookup-variable-value) (const counter) (reg env))
    (restore continue)
    (restore argl)
    (assign argl (op cons) (reg val) (reg argl))
    (restore proc)
    (restore continue)
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-branch14))
    compiled-branch15
    (assign continue (label after-call16))
    (assign val (op compiled-procedure-entry) (reg proc))
    (goto (reg val))
    primitive-branch14
    (save continue)
    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    (restore continue)
    after-call16
    (assign argl (op list) (reg val))
    (restore env)
    (save argl)
    (save continue)
    (save env)
    (save continue)
    (assign proc (op lookup-variable-value) (const *) (reg env))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save proc)
    (save env)
    (save continue)
    (assign val (op lookup-variable-value) (const product) (reg env))
    (restore continue)
    (assign argl (op list) (reg val))
    (restore env)
    (save argl)
    (save continue)
    (assign val (op lookup-variable-value) (const counter) (reg env))
    (restore continue)
    (restore argl)
    (assign argl (op cons) (reg val) (reg argl))
    (restore proc)
    (restore continue)
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-branch11))
    compiled-branch12
    (assign continue (label after-call13))
    (assign val (op compiled-procedure-entry) (reg proc))
    (goto (reg val))
    primitive-branch11
    (save continue)
    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    (restore continue)
    after-call13
    (restore argl)
    (assign argl (op cons) (reg val) (reg argl))
    (restore proc)
    (restore continue)
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-branch17))
    compiled-branch18
    (assign val (op compiled-procedure-entry) (reg proc))
    (goto (reg val))
    primitive-branch17
    (save continue)
    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    (restore continue)
    (goto (reg continue))
    after-call19
    after-if7
    after-lambda4
    (restore env)
    (perform (op define-variable!) (const iter) (reg val) (reg env))
    (assign val (const ok))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save env)
    (save continue)
    (assign proc (op lookup-variable-value) (const iter) (reg env))
    (restore continue)
    (restore env)
    (restore continue)
    (save continue)
    (save proc)
    (save env)
    (save continue)
    (assign val (const 1))
    (restore continue)
    (assign argl (op list) (reg val))
    (restore env)
    (save argl)
    (save continue)
    (assign val (const 1))
    (restore continue)
    (restore argl)
    (assign argl (op cons) (reg val) (reg argl))
    (restore proc)
    (restore continue)
    (test (op primitive-procedure?) (reg proc))
    (branch (label primitive-branch20))
    compiled-branch21
    (assign val (op compiled-procedure-entry) (reg proc))
    (goto (reg val))
    primitive-branch20
    (save continue)
    (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
    (restore continue)
    (goto (reg continue))
    after-call22
    after-lambda2
    (restore env)
    (perform (op define-variable!) (const factorial) (reg val) (reg env))
    (assign val (const ok))
    (restore continue)))
#+end_src

The compiled code is the iterative factorial. The modified compiler generates lots of extra ~save~ and ~restore~ instructions.
